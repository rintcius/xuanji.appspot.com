<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
<meta charset="UTF-8">

<link rel="stylesheet" type="text/css" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/isicp.css" />
<link rel="stylesheet" type="text/css" href="css/footnotes.css" />
<link rel="stylesheet" type="text/css" href="css/theme.css" />

<script src="js/helper.js"></script>
<script src="js/codemirror/lib/codemirror.js"></script>
<script src="js/codemirror/mode/scheme/scheme.js"></script>
<script src="js/jquery.min.js"></script>
<script src="js/coding.js"> </script>
<script src="js/footnotes.js"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$']]}
});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<title> iSICP 2.4 - Multiple Representations for Abstract Data </title>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-36868476-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body>

<div id="sidebox">
  <div class="tab"></div>
  <div class="content">
    
    <p> 
    
    <a href="index.html" class="navlink"> <img src='images/home.svg' width=32 height=32> </a>
    <span id="toc-link" class="navlink"> <img src='images/list.svg' width=32 height=32> </span>
    <span id="currently-editing-link" class="navlink"> <img src='images/file-edit.svg' width=32 height=32> </span>
    
    <p>
    
    <div id="currently-editing"> </div>
    
    <script>
    
    function hideAll() {
      $("#currently-editing").hide();
      $("#toc").hide();
    }
    
    $("#currently-editing-link").click(function() {
      hideAll();
      $("#currently-editing").show();
    });
    
    $("#toc-link").click(function() {
      hideAll();
      $("#toc").show();
    });
    
    </script>
    
    <div id="toc"> </div>
    
    <p style='font-size:12px'> (Click on the left edge of this green box to hide it!)
    
    <script>
    hideAll();
    $("#toc").show();
    </script>
  
  </div>
</div>

<script> 
$('#sidebox .tab').toggle(function(){
    $('#sidebox').animate({'right':'0%'});
}, function(){
    $('#sidebox').animate({'right':'-30%'});
});

$(document).ready(createTOC);

</script>

<div id="main">

<h2> Designing Register Machines </h2> 

<p> To design a register machine, we must design its <tt>data paths</tt> (registers and operations) and the <tt>controller</tt> that sequences these operations. To illustrate the design of a simple register machine, let us examine Euclid's Algorithm, which is used to compute the greatest common divisor (GCD) of two integers. As we saw in section 1-2-5, Euclid's Algorithm can be carried out by an iterative process, as specified by the following procedure:

<div id="">
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</div>
<script>
prompt();
</script>

<p> A machine to carry out this algorithm must keep track of two numbers, a and b, so let us assume that these numbers are stored in two registers with those names. The basic operations required are testing whether the contents of register <tt>b</tt> is zero and computing the remainder of the contents of register <tt>a</tt> divided by the contents of register <tt>b</tt>. The remainder operation is a complex process, but assume for the moment that we have a primitive device that computes remainders. On each cycle of the GCD algorithm, the contents of register <tt>a</tt> must be replaced by the contents of register <tt>b</tt>, and the contents of <tt>b</tt> must be replaced by the remainder of the old contents of <tt>a</tt> divided by the old contents of <tt>b</tt>. It would be convenient if these replacements could be done simultaneously, but in our model of register machines we will assume that only one register can be assigned a new value at each step. To accomplish the replacements, our machine will use a third ``temporary'' register, which we call <tt>t</tt>. (First the remainder will be placed in <tt>t</tt>, then the contents of <tt>b</tt> will be placed in <tt>a</tt>, and finally the remainder stored in <tt>t</tt> will be placed in <tt>b</tt>.)

<p> We can illustrate the registers and operations required for this machine by using the data-path diagram shown in Figure 5-1. In this diagram, the registers (<tt>a</tt>, <tt>b</tt>, and <tt>t</tt>) are represented by rectangles. Each way to assign a value to a register is indicated by an arrow with an <tt>X</tt> behind the head, pointing from the source of data to the register. We can think of the <tt>X</tt> as a button that, when pushed, allows the value at the source to ``flow'' into the designated register. The label next to each button is the name we will use to refer to the button. The names are arbitrary, and can be chosen to have mnemonic value (for example, <tt>a<-b</tt> denotes pushing the button that assigns the contents of register <tt>b</tt> to register <tt>a</tt>). The source of data for a register can be another register (as in the <tt>a<-b</tt> assignment), an operation result (as in the <tt>t<-r</tt> assignment), or a constant (a built-in value that cannot be changed, represented in a data-path diagram by a triangle containing the constant).

<p> An operation that computes a value from constants and the contents of registers is represented in a data-path diagram by a trapezoid containing a name for the operation. For example, the box marked <tt>rem</tt> in Figure 5-1 represents an operation that computes the remainder of the contents of the registers <tt>a</tt> and <tt>b</tt> to which it is attached. Arrows (without buttons) point from the input registers and constants to the box, and arrows connect the operation's output value to registers. A test is represented by a circle containing a name for the test. For example, our GCD machine has an operation that tests whether the contents of register <tt>b</tt> is zero. A test also has arrows from its input registers and constants, but it has no output arrows; its value is used by the controller rather than by the data paths. Overall, the data-path diagram shows the registers and operations that are required for the machine and how they must be connected. If we view the arrows as wires and the <tt>X</tt> buttons as switches, the data-path diagram is very like the wiring diagram for a machine that could be constructed from electrical components.

<div class="exercise">
<b>Figure 5.1:</b> Data paths for a GCD machine.

<pre>
                              ___
+-----+          +-----+     /   \
|  a  |<--(X)----|  b  +--->|  =  |
+--+--+   a<-b   +-+---+     \___/
   |               |  ^        ^
   +------+   +----+  |        |
          |   |      (X) b<-t  |
       .--+---+--.   |       / \
        \  rem  /     |      / O \
         \_____/      |     +-----+
            |         |
           (X) t<-r   |
            |         |
            V         |
         +-----+      |
         |  t  +------+
         +-----+
</pre>
</div>

<p> In order for the data paths to actually compute GCDs, the buttons must be pushed in the correct sequence. We will describe this sequence in terms of a controller diagram, as illustrated in Figure 5-2. The elements of the controller diagram indicate how the data-path components should be operated. The rectangular boxes in the controller diagram identify data-path buttons to be pushed, and the arrows describe the sequencing from one step to the next. The diamond in the diagram represents a decision. One of the two sequencing arrows will be followed, depending on the value of the data-path test identified in the diamond. We can interpret the controller in terms of a physical analogy: Think of the diagram as a maze in which a marble is rolling. When the marble rolls into a box, it pushes the data-path button that is named by the box. When the marble rolls into a decision node (such as the test for <tt>b</tt> = 0), it leaves the node on the path determined by the result of the indicated test. Taken together, the data paths and the controller completely describe a machine for computing GCDs. We start the controller (the rolling marble) at the place marked <tt>start</tt>, after placing numbers in registers <tt>a</tt> and <tt>b</tt>. When the controller reaches <tt>done</tt>, we will find the value of the GCD in register <tt>a</tt>.

<div class="exercise">
<b>Figure 5.2:</b> Controller for a GCD machine.

<pre>
     start
       |
       V
      / \ yes
+--->< = >-----> done
|     \ /
|      | no
|      V
|  +------+
|  | t<-r |
|  +---+--+
|      |
|      V
|  +------+
|  | a<-b |
|  +---+--+
|      |
|      V
|  +------+
+--+ b<-t |
   +------+
</pre>
</div>

<div class="exercise">
<p> <b>Exercise 5.1:</b> Design a register machine to compute factorials using the iterative algorithm specified by the following procedure. Draw data-path and controller diagrams for this machine.

<div id="">
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</div>
<script>
prompt();
</script>
</div>

<h3> A Language for Describing Register Machines </h3> 

<p> Data-path and controller diagrams are adequate for representing simple machines such as GCD, but they are unwieldy for describing large machines such as a Lisp interpreter. To make it possible to deal with complex machines, we will create a language that presents, in textual form, all the information given by the data-path and controller diagrams. We will start with a notation that directly mirrors the diagrams.

<p> We define the data paths of a machine by describing the registers and the operations. To describe a register, we give it a name and specify the buttons that control assignment to it. We give each of these buttons a name and specify the source of the data that enters the register under the button's control. (The source is a register, a constant, or an operation.)  To describe an operation, we give it a name and specify its inputs (registers or constants).

<p> We define the controller of a machine as a sequence of <tt>instructions</tt>

<p> together with <tt>labels</tt> that identify <tt>entry points</tt> in the sequence. An instruction is one of the following:

<ul>
<li>
The name of a data-path button to push to assign a value to a register. (This corresponds to a box in the controller diagram.) 
</li>

<li>
A <tt>test</tt> instruction, that performs a specified test. 
</li>
<li>
A conditional branch (<tt>branch</tt> instruction) to a location indicated by a controller label, based on the result of the previous test. (The test and branch together correspond to a diamond in the controller diagram.)  If the test is false, the controller should continue with the next instruction in the sequence. Otherwise, the controller should continue with the instruction after the label. 
</li>

<li>
An unconditional branch (<tt>goto</tt> instruction) naming a controller label at which to continue execution.
</li>
</ul>

<p> The machine starts at the beginning of the controller instruction sequence and stops when execution reaches the end of the sequence. Except when a branch changes the flow of control, instructions are executed in the order in which they are listed.

<div class="exercise">
<b>Figure 5.3:</b> A specification of the GCD
machine.

<div id="">
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))

 (operations
  ((name rem)
   (inputs (register a) (register b)))
  ((name =)
   (inputs (register b) (constant 0)))))

(controller
 test-b                           ; label
   (test =)                       ; test
   (branch (label gcd-done))      ; conditional branch
   (t<-r)                         ; button push
   (a<-b)                         ; button push
   (b<-t)                         ; button push
   (goto (label test-b))          ; unconditional branch
 gcd-done)                        ; label
</div>
<script>
prompt();
</script>

</div>

<p> Figure 5-3 shows the GCD machine described in this way. This example only hints at the generality of these descriptions, since the GCD machine is a very simple case: Each register has only one button, and each button and test is used only once in the controller.

<p> Unfortunately, it is difficult to read such a description. In order to understand the controller instructions we must constantly refer back to the definitions of the button names and the operation names, and to understand what the buttons do we may have to refer to the definitions of the operation names. We will thus transform our notation to combine the information from the data-path and controller descriptions so that we see it all together.

<p> To obtain this form of description, we will replace the arbitrary button and operation names by the definitions of their behavior. That is, instead of saying (in the controller) ``Push button <tt>t<-r</tt>'' and separately saying (in the data paths) ``Button <tt>t<-r</tt> assigns the value of the <tt>rem</tt> operation to register <tt>t</tt>'' and ``The <tt>rem</tt> operation's inputs are the contents of registers <tt>a</tt> and <tt>b</tt>,'' we will say (in the controller) ``Push the button that assigns to register <tt>t</tt> the value of the <tt>rem</tt> operation on the contents of registers <tt>a</tt> and <tt>b</tt>.''Similarly, instead of saying (in the controller) ``Perform the <tt>=</tt> test''and separately saying (in the data paths) ``The <tt>=</tt> test operates on the contents of register <tt>b</tt> and the constant 0,'' we will say ``Perform the <tt>=</tt> test on the contents of register <tt>b</tt> and the constant 0.''  We will omit the data-path description, leaving only the controller sequence. Thus, the GCD machine is described as follows:

<div id="">
(controller
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
</div>
<script>
prompt();
</script>

<p> This form of description is easier to read than the kind illustrated in Figure 5-3, but it also has disadvantages:

<ul>

<li>
It is more verbose for large machines, because complete descriptions of the data-path elements are repeated whenever the elements are mentioned in the controller instruction sequence. (This is not a problem in the GCD example, because each operation and button is used only once.)  Moreover, repeating the data-path descriptions obscures the actual data-path structure of the machine; it is not obvious for a large machine how many registers, operations, and buttons there are and how they are interconnected.
</li>

<li>
Because the controller instructions in a machine definition look like Lisp expressions, it is easy to forget that they are not arbitrary Lisp expressions. They can notate only legal machine operations. For example, operations can operate directly only on constants and the contents of registers, not on the results of other operations.
</li>
</ul>

<p> In spite of these disadvantages, we will use this register-machine language throughout this chapter, because we will be more concerned with understanding controllers than with understanding the elements and connections in data paths. We should keep in mind, however, that data-path design is crucial in designing real machines.

<div class="exercise">
<b>Exercise 5.2:</b> Use the register-machine language
to describe the iterative factorial machine of Exercise 5-1.
</div>

<h4> Actions </h4> 

<p> Let us modify the GCD machine so that we can type in the numbers whose GCD we want and get the answer printed at our terminal. We will not discuss how to make a machine that can read and print, but will assume (as we do when we use <tt>read</tt> and <tt>display</tt> in Scheme) that they are available as primitive operations.@footnote{This assumption glosses over a great deal of complexity. Usually a large portion of the implementation of a Lisp system is dedicated to making reading and printing work.}

<p> <tt>Read</tt> is like the operations we have been using in that it produces a value that can be stored in a register. But <tt>read</tt> does not take inputs from any registers; its value depends on something that happens outside the parts of the machine we are designing. We will allow our machine's operations to have such behavior, and thus will draw and notate the use of <tt>read</tt> just as we do any other operation that computes a value.

<p> <tt>Print</tt>, on the other hand, differs from the operations we have been using in a fundamental way: It does not produce an output value to be stored in a register. Though it has an effect, this effect is not on a part of the machine we are designing. We will refer to this kind of operation as an <tt>action</tt> . We will represent an action in a data-path diagram just as we represent an operation that computes a value---as a trapezoid that contains the name of the action. Arrows point to the action box from any inputs (registers or constants). We also associate a button with the action. Pushing the button makes the action happen. To make a controller push an action button we use a new kind of instruction called <tt>perform</tt>. Thus, the action of printing the contents of register <tt>a</tt> is represented in a controller sequence by the instruction

<div id="">
(perform (op print) (reg a))
</div>
<script>
prompt();
</script>

<p> Figure 5-4 shows the data paths and controller for the new GCD machine. Instead of having the machine stop after printing the answer, we have made it start over, so that it repeatedly reads a pair of numbers, computes their GCD, and prints the result. This structure is like the driver loops we used in the interpreters of Chapter 4.

<div class="exercise">
<p> <b>Figure 5.4:</b> A GCD machine that reads inputs and prints results.

<pre>
                   .--------.
                    \ read /
                     \____/
                       |
               +-------*------+
               |              |
        a<-rd (X)            (X) b<-rd
               |              |
               V              V           ___
            +-----+        +-----+       /   \
            |  a  |<--(X)--+  b  +----->|  =  |
            +-+-+-+  a<-b  +-+---+       \___/
              | |            |  ^          ^
           +--+ +----+    +--+  |          |
           |         |    |    (X) b<-t   / \
           V         V    V     |        / O \
      .---------. .---------. |       /_____\
--(X)->\ print /    \  rem  /   |
   P    \_____/      \_____/    |
                        |       |
                       (X) t<-r |
                        |       |
                        V       |
                     +-----+    |
                     |  t  +----+
                     +-----+
</pre>

<div id="">
 (controller
  gcd-loop
    (assign a (op read))
    (assign b (op read))
  test-b
    (test (op =) (reg b) (const 0))
    (branch (label gcd-done))
    (assign t (op rem) (reg a) (reg b))
    (assign a (reg b))
    (assign b (reg t))
    (goto (label test-b))
  gcd-done
    (perform (op print) (reg a))
    (goto (label gcd-loop)))
</div>
<script>
prompt();
</script>

</div>

<h3> Abstraction in Machine Design </h3> 

<p> We will often define a machine to include ``primitive'' operations that are actually very complex. For example, in sections 5-4 and 5-5 we will treat Scheme's environment manipulations as primitive. Such abstraction is valuable because it allows us to ignore the details of parts of a machine so that we can concentrate on other aspects of the design. The fact that we have swept a lot of complexity under the rug, however, does not mean that a machine design is unrealistic. We can always replace the complex ``primitives'' by simpler primitive operations.

<p> Consider the GCD machine. The machine has an instruction that computes the remainder of the contents of registers <tt>a</tt> and <tt>b</tt> and assigns the result to register <tt>t</tt>. If we want to construct the GCD machine without using a primitive remainder operation, we must specify how to compute remainders in terms of simpler operations, such as subtraction. Indeed, we can write a Scheme procedure that finds remainders in this way:

<div id="">
(define (remainder n d)
  (if (< n d)
      n
      (remainder (- n d) d)))
</div>
<script>
prompt();
</script>

<p> We can thus replace the remainder operation in the GCD machine's data paths with a subtraction operation and a comparison test. Figure 5-5 shows the data paths and controller for the elaborated machine. The instruction

<div class="exercise">
<p> <b>Figure 5.5:</b> Data paths and controller for the elaborated GCD machine.

<pre>
                                    ___
+-----+         +-----+            /   \
|  a  |<--(X)---+  b  +-------*-->|  =  |
+--+--+   a<-b  +-+---+       |    \___/
   |              |  ^        |
  (X) t<-a        |  |        |
   |              | (X) b<-t  |
   V              |  |       _V_
+-----+           |  |      /   \
|  t  +-------*---|--*-----|  <  |
+-----+       |   |         \___/
   ^          V   V
   |        ---------
  (X) t<-d   \  -  /
   |          --+--
   |            |
   +------------+


   start
     |
     V
    / \ yes            +-------+
+->< = >----> done     | t<-d  |<--+
|   \ /                +---+---+   |
|    | no                  |       |
|    |                     V       |
|    |   +------+         / \ no   |
|    +-->| t<-a +------->< < >-----+
|        +------+         \ /
|                          | yes
|      +-------------------+
|      V
|  +-------+
|  | a<-b  |
|  +---+---+
|      |
|      V
|  +-------+
+--+ b<-t  |
   +-------+
</pre>
</div>

<div id="">
(assign t (op rem) (reg a) (reg b))
</div>
<script>
prompt();
</script>


<p> in the GCD controller definition is replaced by a sequence of instructions that contains a loop, as shown in Figure 5-6.

<div class="exercise">
<p> <b>Figure 5.6:</b> Controller instruction sequence for the GCD machine in Figure 5-5.

<div id="">
(controller
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (reg a))
 rem-loop
   (test (op <) (reg t) (reg b))
   (branch (label rem-done))
   (assign t (op -) (reg t) (reg b))
   (goto (label rem-loop))
 rem-done
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
</div>
<script>
prompt();
</script>

</div>

<div class="exercise">
<p> <b>Exercise 5.3:</b> Design a machine to compute square roots using Newton's method, as described in section 1-1-7:

<div id="">
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</div>
<script>
prompt();
</script>

<p> Begin by assuming that <tt>good-enough?</tt> and <tt>improve</tt> operations are available as primitives. Then show how to expand these in terms of arithmetic operations. Describe each version of the <tt>sqrt</tt> machine design by drawing a data-path diagram and writing a controller definition in the register-machine language.
</div>

<h3> Subroutines </h3> 

<p> When designing a machine to perform a computation, we would often prefer to arrange for components to be shared by different parts of the computation rather than duplicate the components. Consider a machine that includes two GCD computations---one that finds the GCD of the contents of registers <tt>a</tt> and <tt>b</tt> and one that finds the GCD of the contents of registers <tt>c</tt> and <tt>d</tt>. We might start by assuming we have a primitive <tt>gcd</tt> operation, then expand the two instances of <tt>gcd</tt> in terms of more primitive operations. Figure 5-7 shows just the GCD portions of the resulting machine's data paths, without showing how they connect to the rest of the machine. The figure also shows the corresponding portions of the machine's controller sequence.

<div class="exercise">
<p> <b>Figure 5.7:</b> Portions of the data paths and controller sequence for a machine with two GCD computations.

<pre>
                            ___                                 ___  
+-----+        +-----+     /   \    +-----+        +-----+     /   \ 
|  a  |<-(X)---+  b  |--->|  =  |   |  c  |<-(X)---+  d  |--->|  =  |
+--+--+  a<-b  ++----+     \___/    +--+--+  c<-d  ++----+     \___/ 
   |            |  ^         ^         |            |  ^         ^   
   `----.  .---'  |         |         `----.  .---'  |         |   
        V   V     (X) b<-t   |              V   V     (X) d<-t   |   
       -------     |        / \            -------     |        / \  
       \ rem /     |       /_0_\           \ rem /     |       /_0_\ 
        --+--      |                        --+--      |             
          |        |                          |        |             
         (X) t<-r  |                         (X) s<-r  |             
          |        |                          |        |             
          V        |                          V        |             
       +-----+     |                       +-----+     |             
       |  t  +-----'                       |  s  +-----'             
       +-----+                             +-----+                   
</pre>

<div id="">
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
   ...
gcd-2
 (test (op =) (reg d) (const 0))
 (branch (label after-gcd-2))
 (assign s (op rem) (reg c) (reg d))
 (assign c (reg d))
 (assign d (reg s))
 (goto (label gcd-2))
after-gcd-2
</div>
<script>
prompt();
</script>

</div>

<p> This machine has two remainder operation boxes and two boxes for testing equality. If the duplicated components are complicated, as is the remainder box, this will not be an economical way to build the machine. We can avoid duplicating the data-path components by using the same components for both GCD computations, provided that doing so will not affect the rest of the larger machine's computation. If the values in registers <tt>a</tt> and <tt>b</tt> are not needed by the time the controller gets to <tt>gcd-2</tt> (or if these values can be moved to other registers for safekeeping), we can change the machine so that it uses registers <tt>a</tt> and <tt>b</tt>, rather than registers <tt>c</tt> and <tt>d</tt>, in computing the second GCD as well as the first. If we do this, we obtain the controller sequence shown in Figure 5-8.

<p> We have removed the duplicate data-path components (so that the data paths are again as in Figure 5-1), but the controller now has two GCD sequences that differ only in their entry-point labels. It would be better to replace these two sequences by branches to a single sequence---a <tt>gcd</tt> <tt>subroutine</tt> ---at the end of which we branch back to the correct place in the main instruction sequence. We can accomplish this as follows: Before branching to <tt>gcd</tt>, we place a distinguishing value (such as 0 or 1) into a special register, <tt>continue</tt>. At the end of the <tt>gcd</tt> subroutine we return either to <tt>after-gcd-1</tt> or to <tt>after-gcd-2</tt>, depending on the value of the <tt>continue</tt> register. Figure 5-9 shows the relevant portion of the resulting controller sequence, which includes only a single copy of the <tt>gcd</tt> instructions.

<div class="exercise">
<p> <b>Figure 5.8:</b> Portions of the controller sequence for a machine that uses the same data-path components for two different GCD computations.

<div id="">
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
  ...
gcd-2
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-2))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-2))
after-gcd-2
</div>
<script>
prompt();
</script>

</div>

<div class="exercise">
<p> <b>Figure 5.9:</b> Using a <tt>continue</tt> register to avoid the duplicate controller sequence in Figure 5-8.

<div id="">
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
  ...
;; Before branching to <tt>gcd</tt> from the first place where
;; it is needed, we place 0 in the <tt>continue</tt> register
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
  ...
;; Before the second use of <tt>gcd</tt>, we place 1 in the <tt>continue</tt> register
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
</div>
<script>
prompt();
</script>

</div>

<div class="exercise">
<p> <b>Figure 5.10:</b> Assigning labels to the <tt>continue</tt> register simplifies and generalizes the strategy shown in Figure 5-9.

<div id="">
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   ...
;; Before calling <tt>gcd</tt>, we assign to <tt>continue</tt>
;; the label to which <tt>gcd</tt> should return.
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   ...
;; Here is the second call to <tt>gcd</tt>, with a different continuation.
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
</div>
<script>
prompt();
</script>

</div>

<p> This is a reasonable approach for handling small problems, but it would be awkward if there were many instances of GCD computations in the controller sequence. To decide where to continue executing after the <tt>gcd</tt> subroutine, we would need tests in the data paths and branch instructions in the controller for all the places that use <tt>gcd</tt>. A more powerful method for implementing subroutines is to have the <tt>continue</tt> register hold the label of the entry point in the controller sequence at which execution should continue when the subroutine is finished. Implementing this strategy requires a new kind of connection between the data paths and the controller of a register machine: There must be a way to assign to a register a label in the controller sequence in such a way that this value can be fetched from the register and used to continue execution at the designated entry point.

<p> To reflect this ability, we will extend the <tt>assign</tt> instruction of the register-machine language to allow a register to be assigned as value a label from the controller sequence (as a special kind of constant). We will also extend the <tt>goto</tt> instruction to allow execution to continue at the entry point described by the contents of a register rather than only at an entry point described by a constant label. Using these new constructs we can terminate the <tt>gcd</tt> subroutine with a branch to the location stored in the <tt>continue</tt> register. This leads to the controller sequence shown in Figure 5-10.

<p> A machine with more than one subroutine could use multiple continuation registers (e.g., <tt>gcd-continue</tt>, <tt>factorial-continue</tt>) or we could have all subroutines share a single <tt>continue</tt> register. Sharing is more economical, but we must be careful if we have a subroutine (<tt>sub1</tt>) that calls another subroutine (<tt>sub2</tt>). Unless <tt>sub1</tt> saves the contents of <tt>continue</tt> in some other register before setting up <tt>continue</tt> for the call to <tt>sub2</tt>, <tt>sub1</tt> will not know where to go when it is finished. The mechanism developed in the next section to handle recursion also provides a better solution to this problem of nested subroutine calls.

<h3> Using a Stack to Implement Recursion </h3> 

<p> With the ideas illustrated so far, we can implement any iterative process by specifying a register machine that has a register corresponding to each state variable of the process. The machine repeatedly executes a controller loop, changing the contents of the registers, until some termination condition is satisfied. At each point in the controller sequence, the state of the machine (representing the state of the iterative process) is completely determined by the contents of the registers (the values of the state variables).

<p> Implementing recursive processes, however, requires an additional mechanism. Consider the following recursive method for computing factorials, which we first examined in section 1-2-1:

<div id="">
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</div>
<script>
prompt();
</script>

<p> As we see from the procedure, computing n! requires computing (n - 1)!. Our GCD machine, modeled on the procedure

<div id="">
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</div>
<script>
prompt();
</script>

<p> similarly had to compute another GCD. But there is an important difference between the <tt>gcd</tt> procedure, which reduces the original computation to a new GCD computation, and <tt>factorial</tt>, which requires computing another factorial as a subproblem. In GCD, the answer to the new GCD computation is the answer to the original problem. To compute the next GCD, we simply place the new arguments in the input registers of the GCD machine and reuse the machine's data paths by executing the same controller sequence. When the machine is finished solving the final GCD problem, it has completed the entire computation.

<p> In the case of factorial (or any recursive process) the answer to the new factorial subproblem is not the answer to the original problem. The value obtained for (n - 1)! must be multiplied by n to get the final answer. If we try to imitate the GCD design, and solve the factorial subproblem by decrementing the <tt>n</tt> register and rerunning the factorial machine, we will no longer have available the old value of <tt>n</tt> by which to multiply the result. We thus need a second factorial machine to work on the subproblem. This second factorial computation itself has a factorial subproblem, which requires a third factorial machine, and so on. Since each factorial machine contains another factorial machine within it, the total machine contains an infinite nest of similar machines and hence cannot be constructed from a fixed, finite number of parts.

<p> Nevertheless, we can implement the factorial process as a register machine if we can arrange to use the same components for each nested instance of the machine. Specifically, the machine that computes n!  should use the same components to work on the subproblem of computing (n - 1)!, on the subproblem for (n - 2)!, and so on. This is plausible because, although the factorial process dictates that an unbounded number of copies of the same machine are needed to perform a computation, only one of these copies needs to be active at any given time. When the machine encounters a recursive subproblem, it can suspend work on the main problem, reuse the same physical parts to work on the subproblem, then continue the suspended computation.

<p> In the subproblem, the contents of the registers will be different than they were in the main problem. (In this case the <tt>n</tt> register is decremented.) In order to be able to continue the suspended computation, the machine must save the contents of any registers that will be needed after the subproblem is solved so that these can be restored to continue the suspended computation. In the case of factorial, we will save the old value of <tt>n</tt>, to be restored when we are finished computing the factorial of the decremented <tt>n</tt> register.@footnote{One might argue that we don't need to save the old <tt>n</tt>; after we decrement it and solve the subproblem, we could simply increment it to recover the old value. Although this strategy works for factorial, it cannot work in general, since the old value of a register cannot always be computed from the new one.}

<p> Since there is no <em>a priori</em> limit on the depth of nested recursive calls, we may need to save an arbitrary number of register values. These values must be restored in the reverse of the order in which they were saved, since in a nest of recursions the last subproblem to be entered is the first to be finished. This dictates the use of a <tt>stack</tt> , or ``last in, first out'' data structure, to save register values. We can extend the register-machine language to include a stack by adding two kinds of instructions: Values are placed on the stack using a <tt>save</tt> instruction and restored from the stack using a <tt>restore</tt> instruction. After a sequence of values has been <tt>save</tt>d on the stack, a sequence of <tt>restore</tt>s will retrieve these values in reverse order.@footnote{In section 5-3 we will see how to implement a stack in terms of more primitive operations.}

<p> With the aid of the stack, we can reuse a single copy of the factorial machine's data paths for each factorial subproblem. There is a similar design issue in reusing the controller sequence that operates the data paths. To reexecute the factorial computation, the controller cannot simply loop back to the beginning, as with an iterative process, because after solving the (n - 1)! subproblem the machine must still multiply the result by n. The controller must suspend its computation of n!, solve the (n - 1)! subproblem, then continue its computation of n!. This view of the factorial computation suggests the use of the subroutine mechanism described in section 5-1-3, which has the controller use a <tt>continue</tt> register to transfer to the part of the sequence that solves a subproblem and then continue where it left off on the main problem. We can thus make a factorial subroutine that returns to the entry point stored in the <tt>continue</tt> register. Around each subroutine call, we save and restore <tt>continue</tt> just as we do the <tt>n</tt> register, since each ``level'' of the factorial computation will use the same <tt>continue</tt> register. That is, the factorial subroutine must put a new value in <tt>continue</tt> when it calls itself for a subproblem, but it will need the old value in order to return to the place that called it to solve a subproblem.

<p> Figure 5-11 shows the data paths and controller for a machine that implements the recursive <tt>factorial</tt> procedure. The machine has a stack and three registers, called <tt>n</tt>, <tt>val</tt>, and <tt>continue</tt>. To simplify the data-path diagram, we have not named the register-assignment buttons, only the stack-operation buttons (<tt>sc</tt> and <tt>sn</tt> to save registers, <tt>rc</tt> and <tt>rn</tt> to restore registers). To operate the machine, we put in register <tt>n</tt> the number whose factorial we wish to compute and start the machine. When the machine reaches <tt>fact-done</tt>, the computation is finished and the answer will be found in the <tt>val</tt> register. In the controller sequence, <tt>n</tt> and <tt>continue</tt> are saved before each recursive call and restored upon return from the call. Returning from a call is accomplished by branching to the location stored in <tt>continue</tt>. <tt>Continue</tt> is initialized when the machine starts so that the last return will go to <tt>fact-done</tt>. The <tt>val</tt> register, which holds the result of the factorial computation, is not saved before the recursive call, because the old contents of <tt>val</tt> is not useful after the subroutine returns. Only the new value, which is the value produced by the subcomputation, is needed.

<p> Although in principle the factorial computation requires an infinite machine, the machine in Figure 5-11 is actually finite except for the stack, which is potentially unbounded. Any particular physical implementation of a stack, however, will be of finite size, and this will limit the depth of recursive calls that can be handled by the machine. This implementation of factorial illustrates the general strategy for realizing recursive algorithms as ordinary register machines augmented by stacks. When a recursive subproblem is encountered, we save on the stack the registers whose current values will be required after the subproblem is solved, solve the recursive subproblem, then restore the saved registers and continue execution on the main problem. The <tt>continue</tt> register must always be saved. Whether there are other registers that need to be saved depends on the particular machine, since not all recursive computations need the original values of registers that are modified during solution of the subproblem (see Exercise 5-4).

<h4> A double recursion </h4> 

<p> Let us examine a more complex recursive process, the tree-recursive computation of the Fibonacci numbers, which we introduced in section 1-2-2:

<div id="">
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
</div>
<script>
prompt();
</script>

<p> Just as with factorial, we can implement the recursive Fibonacci computation as a register machine with registers <tt>n</tt>, <tt>val</tt>, and <tt>continue</tt>. The machine is more complex than the one for factorial, because there are two places in the controller sequence where we need to perform recursive calls---once to compute Fib(n - 1) and once to compute Fib(n - 2). To set up for each of these calls, we save the registers whose values will be needed later, set the <tt>n</tt> register to the number whose Fib we need to compute recursively (n - 1 or n - 2), and assign to <tt>continue</tt> the entry point in the main sequence to which to return (<tt>afterfib-n-1</tt> or <tt>afterfib-n-2</tt>, respectively). We then go to <tt>fib-loop</tt>. When we return from the recursive call, the answer is in <tt>val</tt>. Figure 5-12 shows the controller sequence for this machine.

<div class="exercise">
<b>Figure 5.11:</b> A recursive factorial machine.

<pre>
                             ___
                            /   \
    +----------*-----------|  =  |
    |          |            \___/
   (X)         |              ^
    |          |              |
    V          |          +---+---+   sn    +-------+
+-------+      |          |       +---(X)-->|       |
|  val  |<-(X)-|----------+   n   |         | stack |
+-----+-+      |          |       |<--(X)---+       |
  ^   |        |          +-------+   rn    +-+-----+
  |   |        |            ^                 |   ^
 (X)  |        |            |                 |   |
  |   |   +----|--------*  (X)                |  (X) sc
  |   |   |    |        |   |             rc (X)  |
  |   |   |    *----.  |   |                 |   |
  |   V   V    |    V   V   |                 V   |
  |  -------   |   -------  |              +------+-+
  |  \  *  /   |   \  -  /  |              |continue+--> controller
  |   --+--    |    --+--   |              +--------+
  |     |      |      |     |               ^      ^
  +-----+      |      +-----+               |      |
               |                           (X)    (X)
               |                            |      |
              / \                   after- / \    / \  fact-
             /_1_\                  fact  /___\  /___\ done
</pre>

<div id="">
(controller
   (assign continue (label fact-done))     ; set up final return address
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ;; Set up for the recursive call by saving <tt>n</tt> and <tt>continue</tt>.
   ;; Set up <tt>continue</tt> so that the computation will continue
   ;; at <tt>after-fact</tt> when the subroutine returns.
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val))   ; <tt>val</tt> now contains n(n - 1)!
   (goto (reg continue))                   ; return to caller
 base-case
   (assign val (const 1))                  ; base case: 1! = 1
   (goto (reg continue))                   ; return to caller
 fact-done)
</div>
<script>
prompt();
</script>

</div>

<div class="exercise">
<b>Figure 5.12:</b> Controller for a machine to compute
Fibonacci numbers.

<div id="">
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   ;; set up to compute <em>Fib</em>(n - 1)
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                           ; save old value of <tt>n</tt>
   (assign n (op -) (reg n) (const 1)); clobber <tt>n</tt> to n - 1
   (goto (label fib-loop))            ; perform recursive call
 afterfib-n-1                         ; upon return, <tt>val</tt> contains <em>Fib</em>(n - 1)
   (restore n)
   (restore continue)
   ;; set up to compute <em>Fib</em>(n - 2)
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                         ; save <em>Fib</em>(n - 1)
   (goto (label fib-loop))
 afterfib-n-2                         ; upon return, <tt>val</tt> contains <em>Fib</em>(n - 2)
   (assign n (reg val))               ; <tt>n</tt> now contains <em>Fib</em>(n - 2)
   (restore val)                      ; <tt>val</tt> now contains <em>Fib</em>(n - 1)
   (restore continue)
   (assign val                        ;  <em>Fib</em>(n - 1) +  <em>Fib</em>(n - 2)
           (op +) (reg val) (reg n))
   (goto (reg continue))              ; return to caller, answer is in <tt>val</tt>
 immediate-answer
   (assign val (reg n))               ; base case:  <em>Fib</em>(n) = n
   (goto (reg continue))
 fib-done)
</div>
<script>
prompt();
</script>

</div>

<div class="exercise">
<p> <b>Exercise 5.4:</b> Specify register machines that implement each of the following procedures. For each machine, write a controller instruction sequence and draw a diagram showing the data paths.

<ul>
@item
Recursive exponentiation:

<div id="">
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
</div>
<script>
prompt();
</script>

@item
Iterative exponentiation:

<div id="">
(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1) (* b product))))
  (expt-iter n 1))
</div>
<script>
prompt();
</script>

</ul>
</div>

<div class="exercise">
<p> <b>Exercise 5.5:</b> Hand-simulate the factorial and Fibonacci machines, using some nontrivial input (requiring execution of at least one recursive call). Show the contents of the stack at each significant point in the execution.
</div>

<div class="exercise">
<p> <b>Exercise 5.6:</b> Ben Bitdiddle observes that the Fibonacci machine's controller sequence has an extra <tt>save</tt> and an extra <tt>restore</tt>, which can be removed to make a faster machine. Where are these instructions?
</div>

<h3> Instruction Summary </h3> 

<p> A controller instruction in our register-machine language has one of the following forms, where each <input_i> is either <tt>(reg <register-name</tt>>) or <tt>(const <constant-value</tt>>). These instructions were introduced in section 5-1-1:

<div id="">
(assign &lt;register-name&gt; (reg &lt;register-name&gt;))

(assign &lt;register-name&gt; (const &lt;constant-value&gt;))

(assign &lt;register-name&gt; (op &lt;operation-name&gt;) &lt;input_1&gt; ... &lt;input_n&gt;)

(perform (op &lt;operation-name&gt;) &lt;input_1&gt; ... &lt;input_n&gt;)

(test (op &lt;operation-name&gt;) &lt;input_1&gt; ... &lt;input_n&gt;)

(branch (label &lt;label-name&gt;))

(goto (label &lt;label-name&gt;))
</div>
<script>
prompt();
</script>

<p> The use of registers to hold labels was introduced in section 5-1-3:

<div id="">
(assign <register-name> (label <label-name>))

(goto (reg <register-name>))
</div>
<script>
prompt();
</script>

<p> Instructions to use the stack were introduced in section 5-1-4:

<div id="">
(save <register-name>)

(restore <register-name>)
</div>
<script>
prompt();
</script>

<p> The only kind of <constant-value> we have seen so far is a number, but later we will use strings, symbols, and lists. For example,@* <tt>(const "abc")</tt> is the string <tt>"abc"</tt>,@* <tt>(const abc)</tt> is the symbol <tt>abc</tt>,@* <tt>(const (a b c))</tt> is the list <tt>(a b c)</tt>,@* and <tt>(const ())</tt> is the empty list.
 @@

<br>
<br>

<hr>

<div id="footnotes">
<h3 id='Notes'> Notes </h3>
 </div>

<hr>

<p> <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br /> Based on Structure and Interpretation of Computer Programs, a work at <a xmlns:dct="http://purl.org/dc/terms/" href="http://mitpress.mit.edu/sicp/" rel="dct:source" target="_blank">http://mitpress.mit.edu/sicp/</a>.

</div>

<script> 

var todo = Object.keys(editorOf);

(function proc() {
  if (todo.length == 0) {
    return;
  }
  try {
    editorOf[todo.shift()].getOption("onBlur")().then(proc);
  } catch (err) {
    proc();
  }    
})();


</script>

<a href="https://github.com/zodiac/xuanji.appspot.com/tree/master/isicp" target="_blank"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>

</body>
</html>
